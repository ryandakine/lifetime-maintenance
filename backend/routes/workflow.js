const express = require('express');
const router = express.Router();
const workflowService = require('../services/workflow-automation');

// POST /api/workflow/trigger - Trigger workflow automation from photo analysis
router.post('/trigger', async (req, res) => {
  try {
    const { analysis, context } = req.body;
    
    if (!analysis) {
      return res.status(400).json({
        success: false,
        error: 'Analysis data is required'
      });
    }

    console.log('ðŸ”„ Triggering workflow automation...');
    
    const result = await workflowService.processPhotoAnalysis(analysis, context);
    
    if (result.success) {
      res.json({
        success: true,
        message: `Generated ${result.tasks.length} tasks from photo analysis`,
        data: {
          tasks: result.tasks,
          triggeredRules: result.triggeredRules,
          timestamp: result.timestamp
        }
      });
    } else {
      res.status(500).json({
        success: false,
        error: 'Failed to process workflow automation',
        message: result.error
      });
    }

  } catch (error) {
    console.error('Workflow trigger error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// GET /api/workflow/stats - Get workflow automation statistics
router.get('/stats', async (req, res) => {
  try {
    const { dateRange = '30d' } = req.query;
    
    const stats = await workflowService.getWorkflowStats(dateRange);
    
    if (stats) {
      res.json({
        success: true,
        data: stats
      });
    } else {
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve workflow statistics'
      });
    }

  } catch (error) {
    console.error('Workflow stats error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// GET /api/workflow/rules - Get current workflow rules
router.get('/rules', async (req, res) => {
  try {
    res.json({
      success: true,
      data: {
        rules: workflowService.rules,
        maintenanceSchedules: workflowService.maintenanceSchedules,
        taskTemplates: workflowService.taskTemplates
      }
    });

  } catch (error) {
    console.error('Workflow rules error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// POST /api/workflow/rules - Update workflow rules
router.post('/rules', async (req, res) => {
  try {
    const { rules, maintenanceSchedules, taskTemplates } = req.body;
    
    if (rules) {
      workflowService.rules = { ...workflowService.rules, ...rules };
    }
    
    if (maintenanceSchedules) {
      workflowService.maintenanceSchedules = { ...workflowService.maintenanceSchedules, ...maintenanceSchedules };
    }
    
    if (taskTemplates) {
      workflowService.taskTemplates = { ...workflowService.taskTemplates, ...taskTemplates };
    }
    
    res.json({
      success: true,
      message: 'Workflow rules updated successfully'
    });

  } catch (error) {
    console.error('Workflow rules update error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// POST /api/workflow/test - Test workflow rules with sample data
router.post('/test', async (req, res) => {
  try {
    const { analysis, context } = req.body;
    
    if (!analysis) {
      return res.status(400).json({
        success: false,
        error: 'Analysis data is required for testing'
      });
    }

    console.log('ðŸ§ª Testing workflow rules...');
    
    // Test each rule individually
    const ruleTests = [];
    
    for (const [ruleName, rule] of Object.entries(workflowService.rules)) {
      const isTriggered = rule.condition(analysis);
      ruleTests.push({
        rule: ruleName,
        triggered: isTriggered,
        action: rule.action,
        priority: rule.priority
      });
    }

    // Test task generation without actually creating tasks
    const mockResult = await workflowService.processPhotoAnalysis(analysis, context);
    
    res.json({
      success: true,
      data: {
        ruleTests,
        wouldGenerateTasks: mockResult.tasks.length,
        triggeredRules: mockResult.triggeredRules,
        sampleTask: mockResult.tasks.length > 0 ? mockResult.tasks[0] : null
      }
    });

  } catch (error) {
    console.error('Workflow test error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// GET /api/workflow/tasks - Get tasks generated by workflow automation
router.get('/tasks', async (req, res) => {
  try {
    const { dateRange = '30d', status, priority } = req.query;
    
    const startDate = workflowService.calculateStartDate(dateRange);
    
    let query = `
      SELECT t.*, e.name as equipment_name, e.type as equipment_type
      FROM Tasks t
      LEFT JOIN Equipment e ON t.equipment_id = e.id
      WHERE t.creation_date >= datetime(?)
    `;
    
    const params = [startDate.toISOString()];
    
    if (status) {
      query += ' AND t.status = ?';
      params.push(status);
    }
    
    if (priority) {
      query += ' AND t.priority = ?';
      params.push(priority);
    }
    
    query += ' ORDER BY t.creation_date DESC';
    
    // Execute query
    const tasks = await new Promise((resolve, reject) => {
      workflowService.db.all(query, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows || []);
      });
    });
    
    res.json({
      success: true,
      data: {
        tasks,
        total: tasks.length,
        dateRange
      }
    });

  } catch (error) {
    console.error('Workflow tasks error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// POST /api/workflow/schedule - Create scheduled maintenance tasks
router.post('/schedule', async (req, res) => {
  try {
    const { equipmentId, equipmentType, scheduleType, location } = req.body;
    
    if (!equipmentId || !equipmentType || !scheduleType) {
      return res.status(400).json({
        success: false,
        error: 'Equipment ID, type, and schedule type are required'
      });
    }

    console.log(`ðŸ“… Creating scheduled maintenance for ${equipmentType}...`);
    
    const context = {
      equipmentId,
      equipmentType,
      location: location || 'Unknown'
    };
    
    const scheduledTasks = await workflowService.generateScheduledTasks({}, context);
    
    res.json({
      success: true,
      message: `Created ${scheduledTasks.length} scheduled maintenance tasks`,
      data: {
        tasks: scheduledTasks,
        equipmentType,
        scheduleType
      }
    });

  } catch (error) {
    console.error('Workflow schedule error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// GET /api/workflow/notifications - Get notification history
router.get('/notifications', async (req, res) => {
  try {
    const { dateRange = '7d' } = req.query;
    
    // In a real system, this would query a notifications table
    // For now, return mock notification history
    const notifications = [
      {
        id: 1,
        type: 'urgent',
        title: 'Critical Issue Detected',
        message: 'Critical issue detected on Treadmill A1',
        timestamp: new Date().toISOString(),
        read: false
      },
      {
        id: 2,
        type: 'standard',
        title: 'Maintenance Task Created',
        message: 'Routine maintenance task created for Elliptical B2',
        timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
        read: true
      }
    ];
    
    res.json({
      success: true,
      data: {
        notifications,
        unreadCount: notifications.filter(n => !n.read).length,
        totalCount: notifications.length
      }
    });

  } catch (error) {
    console.error('Workflow notifications error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

// POST /api/workflow/notifications/read - Mark notifications as read
router.post('/notifications/read', async (req, res) => {
  try {
    const { notificationIds } = req.body;
    
    if (!notificationIds || !Array.isArray(notificationIds)) {
      return res.status(400).json({
        success: false,
        error: 'Notification IDs array is required'
      });
    }

    // In a real system, this would update the notifications table
    console.log(`ðŸ“§ Marking ${notificationIds.length} notifications as read`);
    
    res.json({
      success: true,
      message: `Marked ${notificationIds.length} notifications as read`
    });

  } catch (error) {
    console.error('Workflow notifications read error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: error.message
    });
  }
});

module.exports = router; 