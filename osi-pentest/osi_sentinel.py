#!/usr/bin/env python3
import time
import threading
import sys
import re
import argparse
from datetime import datetime
from collections import defaultdict
from scapy.all import sniff, IP, TCP, UDP

# AI / ML Imports
try:
    import numpy as np
    from sklearn.ensemble import IsolationForest
    from sklearn.preprocessing import StandardScaler
except ImportError:
    print("Missing sklearn/numpy. Run: pip install scikit-learn numpy")
    sys.exit(1)

from rich.console import Console
from rich.layout import Layout
from rich.live import Live
from rich.table import Table
from rich.panel import Panel

console = Console()

class SentinelEngine:
    def __init__(self, interface="eth0", learning_mode=True):
        self.interface = interface
        self.learning_mode = learning_mode
        self.traffic_flows = defaultdict(int) # (src, dst, dport) -> byte_count
        self.usb_events = []
        self.ssh_events = []
        self.anomalies = []
        
        # AI Model for Traffic Baseline
        self.model = IsolationForest(contamination=0.01, random_state=42)
        self.scaler = StandardScaler()
        self.flow_history = [] # List of [bytes, packet_count, duration]
        self.is_trained = False
        
        console.print("[bold green]OSI SENTINEL INITIALIZING...[/bold green]")

    def packet_callback(self, packet):
        """Ingest network traffic"""
        if IP in packet:
            src = packet[IP].src
            dst = packet[IP].dst
            proto = packet[IP].proto
            length = len(packet)
            
            # Simple aggregation key
            key = (src, dst, proto)
            self.traffic_flows[key] += length
            
            # Feature extraction for AI (Simplified)
            # In real-world, we'd aggregate over 1-minute windows
            # Here we just feed raw packet size + simplistic features for demo
            features = [length, 1 if proto==6 else 0] 
            
            if self.is_trained and not self.learning_mode:
                # Real-time inference
                # Reshape for single sample
                prediction = self.model.predict([features])
                if prediction[0] == -1:
                    self.anomalies.append(f"Traffic Anomaly: {src} -> {dst} ({length} bytes)")

            elif self.learning_mode:
                self.flow_history.append(features)
                if len(self.flow_history) > 1000: # Train every 1000 packets
                    self.train_model()

    def train_model(self):
        """Train AI on baseline traffic"""
        data = np.array(self.flow_history)
        self.model.fit(data)
        self.is_trained = True
        # Reset history to keep memory low, or keep rolling window
        self.flow_history = self.flow_history[-500:] 
        # timestamp = datetime.now().strftime("%H:%M:%S")
        # console.print(f"[dim]{timestamp} - Baseline Updated (Trained on {len(data)} samples)[/dim]")

    def monitor_logs(self):
        """Watch system logs for USB/SSH"""
        # Simplistic tail of auth.log logic
        log_file = "/var/log/auth.log"
        try:
            f = open(log_file, "r")
            f.seek(0, 2) # Go to end
            while True:
                line = f.readline()
                if not line:
                    time.sleep(0.1)
                    continue
                
                if "sshd" in line:
                    if "Accepted" in line:
                         self.ssh_events.append(f"[green]SSH LOGIN:[/green] {line.strip()}")
                    elif "Failed" in line:
                         self.ssh_events.append(f"[red]SSH FAILED:[/red] {line.strip()}")
                         
                if "usb" in line.lower(): # Often in syslog/kern.log, but checks auth too sometimes
                    self.usb_events.append(f"[yellow]USB EVENT:[/yellow] {line.strip()}")
        except FileNotFoundError:
            self.ssh_events.append("[dim]Log file not found (Permissions?)[/dim]")

    def start(self):
        # Start Sniffer Thread
        t_sniff = threading.Thread(target=lambda: sniff(iface=self.interface, prn=self.packet_callback, store=0))
        t_sniff.daemon = True
        t_sniff.start()
        
        # Start Log Thread
        t_log = threading.Thread(target=self.monitor_logs)
        t_log.daemon = True
        t_log.start()
        
        # UI Loop
        with Live(self.generate_dashboard(), refresh_per_second=4) as live:
            while True:
                time.sleep(0.25)
                live.update(self.generate_dashboard())

    def generate_dashboard(self):
        layout = Layout()
        layout.split_column(
            Layout(name="header", size=3),
            Layout(name="body", ratio=1)
        )
        layout["body"].split_row(
            Layout(name="left"),
            Layout(name="right")
        )
        
        # Header
        mode = "LEARNING BASELINE" if self.learning_mode else "ACTIVE PROTECTION"
        style = "bold yellow" if self.learning_mode else "bold green"
        layout["header"].update(Panel(f"OSI SENTINEL - {mode}", style=style))
        
        # Traffic Table
        table = Table(title="Top Network Flows")
        table.add_column("Source")
        table.add_column("Destination")
        table.add_column("Bytes")
        
        # Sort by bytes
        sorted_flows = sorted(self.traffic_flows.items(), key=lambda x: x[1], reverse=True)[:10]
        for (src, dst, proto), bytes_count in sorted_flows:
            table.add_row(src, dst, str(bytes_count))
            
        layout["left"].update(Panel(table))
        
        # Events Panel
        alert_text = "[bold underline]SECURITY ALERTS[/bold underline]\n"
        for a in self.anomalies[-5:]:
            alert_text += f"[red]âš  {a}[/red]\n"
        
        alert_text += "\n[bold underline]SSH/USB EVENTS[/bold underline]\n"
        for e in self.ssh_events[-5:]:
            alert_text += f"{e}\n"
            
        layout["right"].update(Panel(alert_text, title="Threat Intelligence"))
        
        return layout

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--iface", default="eth0", help="Network Interface to Monitor")
    args = parser.parse_args()
    
    # Root check helper
    if os.geteuid() != 0:
        print("Sentinel requires ROOT to sniff packets. Run with sudo.")
        sys.exit(1)
        
    engine = SentinelEngine(interface=args.iface)
    engine.start()
